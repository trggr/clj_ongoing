{"ts":1351820678195,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1351820773062,"patch":[[{"diffs":[[1,"(ns 4clojure.core)\r\n\r\n\r\n;;\r\n;; Solutions to 4clojure.com riddles\r\n;;\r\n(fn [coll n]\r\n  \"Find nth element of a sequence\"\r\n  (loop [i 0 c coll]\r\n    (if (= i n)\r\n      (first c)\r\n      (recur (inc i) (rest c)))))\r\n\r\n\r\n\r\n(fn [coll]\r\n   \"Returns the total number of elements in a sequence.\"\r\n   (loop [n 0 c coll]\r\n     (if-not c\r\n       n\r\n       (recur (inc n) (next c)))))\r\n\r\n\r\n(fn [coll]\r\n  \"Reverses a sequence\"\r\n  (loop [acc '() c coll]\r\n    (if-not c\r\n      acc\r\n      (recur (conj acc (first c))\r\n         (next c)))))\r\n\r\n(fn [coll]\r\n  \"Returns the sum of a sequence of numbers\"\r\n  (reduce + coll))\r\n\r\n\r\n(fn [coll]\r\n  \"Returns only the odd numbers from a sequence\"\r\n  (filter odd? coll))\r\n\r\n(fn [n]\r\n  \"Returns the first Fibonacci numbers\"\r\n  (loop [i 0 fib []]\r\n    (if (= i n)\r\n      fib\r\n      (recur (inc i)\r\n\t     (cond (= i 0) (conj fib 1)\r\n\t\t   (= i 1) (conj fib 1)\r\n\t\t   :else (conj fib (+ (fib (- i 1))\r\n\t\t\t\t      (fib (- i 2)))))))))\r\n\r\n(fn [coll]\r\n  \"Returns true if coll is palindrome\"\r\n  (let [s (seq coll)]\r\n    (= (reverse s) s)))\r\n\r\n\r\n(fn [coll]\r\n  \"Flattens a sequence\"\r\n  (letfn [(f [acc coll]\r\n\t     (println (format \"acc=%s, coll=%s\" acc coll))\r\n\t     (let [e (first coll)]\r\n\t       (cond (nil? e)  acc\r\n\t\t     (coll? e) (f (f acc e) (rest coll))\r\n\t\t     :else (f (conj acc e) (rest coll)))))]\r\n    (reverse (f '() coll))))\r\n\r\n\r\n(fn [x]\r\n  \"Takes a string and returns a new string containing only the capital letters\"\r\n  (apply str (filter #(Character/isUpperCase %) (seq x))))\r\n\r\n\r\n(fn [coll]\r\n  \"Removes consecutive duplicates from a sequence\"\r\n  (loop [prev nil s coll acc []]\r\n    (let [cur (first s)]\r\n      (cond (nil? cur) acc\r\n        (= cur prev) (recur prev (rest s) acc)\r\n\t:else (recur cur (rest s) (conj acc cur))))))\r\n\r\n(fn [coll]\r\n  \"Packs consecutive duplicates into sub-lists\"\r\n  (partition-by identity coll))\r\n\r\n(fn [coll]\r\n  \"Duplicates each element of a sequence\"\r\n  (loop [acc [] c coll]\r\n    (let [p (first c)]\r\n      (if (nil? p)\r\n\tacc\r\n\t(recur (conj acc p p) (rest c))))))\r\n\r\n(defn dup-n [coll n]\r\n  \"Duplicates each element of a sequence n times\"\r\n  (loop [acc [] c coll]\r\n    (let [p (first c)]\r\n      (if (nil? p)\r\n\tacc\r\n\t(recur (apply conj acc (for [i (range 0 n)] p)) (rest c))))))\r\n\r\n(fn [coll n]\r\n  \"Duplicates each element of a sequence n times\"\r\n  (loop [acc [] c coll]\r\n    (let [p (first c)]\r\n      (if (nil? p)\r\n\tacc\r\n\t(recur (apply conj acc (for [i (range 0 n)] p)) (rest c))))))\r\n\r\n(fn [n m]\r\n  \"Creates a list of all integers in a given range\"\r\n  (loop [i n acc []]\r\n    (if (= i m)\r\n      acc\r\n      (recur (inc i) (conj acc i)))))\r\n\r\n;; \"Let in Be\" solution to bind x y z\r\n[z 1 x 7 y 3]\r\n\r\n;; Regular expressions\r\n\"ABC\"\r\n\r\n(fn [& args]\r\n  \"Returns a maximum among its arguments\"\r\n  (reduce #(if (> %1 %2) %1 %2) (first args) args))\r\n\r\n(fn [a b]\r\n  \"Interleaves two sequences\"\r\n  (flatten (map #(list %1 %2) a b)))\r\n\r\n;; Not a solution, but useful function\r\n(defn map2\r\n  \"Takes fn and sequence. And calls fn upon pair elements of a sequence;\r\n   fn should accept two arguments\"\r\n  [f coll]\r\n  (loop [acc []\r\n\t s coll]\r\n    (let [e (first s) g (second s)]\r\n      (cond (nil? e) acc\r\n\t    (nil? g) (recur (conj acc e) (rest s))\r\n\t    :else (recur (conj acc (f e g))\r\n\t\t\t (rest s))))))\r\n\t\r\n(fn [val coll]\r\n  \"Separates the items of a sequence by an arbitrary value\"\r\n  (if (empty? coll)\r\n    coll\r\n    (reduce #(conj %1 val %2) [(first coll)] (rest coll))))\r\n\r\n(fn [coll n]\r\n  \"drops every n-th item from a sequence\"\r\n  (loop [acc [] s coll i 1]\r\n    (let [e (first s)]\r\n      (if-not e\r\n\tacc\r\n\t(recur (if (= 0 (mod i n)) acc (conj acc e))\r\n\t       (rest s)\r\n\t       (inc i))))))\r\n\r\n(defn tmp [n]\r\n  \"Calculates factorial\"\r\n  (loop [acc 1 i 1]\r\n    (if (> i n)\r\n      acc\r\n      (recur (* acc i) (inc i)))))\r\n\r\n(fn [n]\r\n  \"Calculates factorial\"\r\n  (loop [acc 1 i 1]\r\n    (if (> i n)\r\n      acc\r\n      (recur (* acc i) (inc i)))))\r\n\r\n(defn tmp [coll n]\r\n  \"Reverses the interleave process into n number of subsequences\"\r\n  (loop [acc [] s coll cur 0]\r\n    (let [e (first s)]\r\n      (if-not e\r\n\tacc\r\n\t(recur (assoc acc cur\r\n\t\t      (conj (if (> cur (dec (count acc))) [] (acc cur))\r\n\t\t       e))\r\n\t       (rest s)\r\n\t       (mod (inc cur) n))))))\r\n\r\n(fn [coll n]\r\n  \"Reverses the interleave process into n number of subsequences\"\r\n  (loop [acc [] s coll cur 0]\r\n    (let [e (first s)]\r\n      (if-not e\r\n\tacc\r\n\t(recur (assoc acc cur\r\n\t\t      (conj (if (> cur (dec (count acc))) [] (acc cur))\r\n\t\t       e))\r\n\t       (rest s)\r\n\t       (mod (inc cur) n))))))\r\n\r\n(fn [n v]\r\n  \"Rotates sequence n times. If n < 0 rotates right, if n > 0 rotates left\"\r\n  (let [m (dec (count v))\r\n\tstep (cond (zero? n) 0\r\n\t\t   (< n 0) 1\r\n\t\t   :else -1)]\r\n    (loop [i n acc (if (vector? v) v (vec v))]\r\n      (if (zero? i)\r\n\tacc\r\n\t(recur (+ i step)\r\n\t       (if (< n 0)\r\n\t\t (vec (list* (last acc) (subvec acc 0 m)))\r\n\t\t (conj (subvec acc 1) (first acc))))))))\r\n\r\n;; Solution to \"Intro to iterate\"\r\n'(1 4 7 10 13)\r\n\r\n\r\n;; Solution to \"Contain yourself\"\r\n4\r\n\r\n;; Solution to \"Intro to some\"\r\n6\r\n\r\n(fn [f]\r\n  \"Flips the order of arguments of f\"\r\n  (fn [x y]\r\n    (f y x)))\r\n\r\n(fn [n a]\r\n  \"Split a sequence into two parts\"\r\n  (loop [acc [] s a i n]\r\n    (let [e (first s)]\r\n      (if (zero? i)\r\n\t(vector acc (vec s))\r\n\t(recur (conj acc e)\r\n\t       (rest s)\r\n\t       (dec i))))))\r\n\r\n;; Solution to \"Split by Type\"\r\n(fn [a]\r\n  \"Split a sequence by type\"\r\n  (vals (group-by type a)))\r\n\r\n;; Solution to \"Intro to Destructuring\"\r\n[c e]\r\n\r\n;; Solution to \"Advanced Destructuring\"\r\n'(1 2 3 4 5)\r\n\r\n(fn [x]\r\n  \"Find a longest increasing sub-sequence\"\r\n  (letfn [(compete\r\n\t   [wannabe established]\r\n\t   (if (> (count wannabe) (count established))\r\n\t     wannabe established))]\r\n    (loop [candidate [] champ [] a x]\r\n      (let [e (first a)]\r\n\t(if-not e\r\n\t  (let [rc (compete candidate champ)] (if (> (count rc) 1) rc []))\r\n\t  (if (or (empty? candidate) (<= e (peek candidate)))\r\n\t    (recur [e]  (compete candidate champ)  (rest a))\r\n\t    (recur (conj candidate e)  champ  (rest a))))))))\r\n\r\n(fn [n x]\r\n  \"Returns a sequence of lists of n items each.\r\n   Lists of less than x items not returned\"\r\n  (loop [acc [] a x i 0 part []]\r\n    (let [e (first a)]\r\n      (if-not e\r\n\t(if (= n (count part))\r\n\t  (conj acc part)\r\n\t  acc)\r\n\t(if (= i n)\r\n\t  (recur (conj acc part)\r\n\t\t (rest a)\r\n\t\t 1\r\n\t\t [e])\r\n\t  (recur acc\r\n\t\t (rest a)\r\n\t\t (inc i)\r\n\t\t (conj part e)))))))\r\n\r\n(defn tmp [x]\r\n  \"Returns a map containing the number of occurences of each distinct item in a sequence\"\r\n  (loop [acc {} a (group-by identity x)]\r\n    (let [e (first a)]\r\n      (if-not e\r\n\tacc\r\n\t(recur (assoc acc (key e) (count (val e)))\r\n\t       (rest a))))))\r\n\r\n(fn [x]\r\n  \"Returns a map containing the number of occurences of each distinct item in a sequence\"\r\n  (loop [acc {} a (group-by identity x)]\r\n    (let [e (first a)]\r\n      (if-not e\r\n\tacc\r\n\t(recur (assoc acc (key e) (count (val e)))\r\n\t       (rest a))))))\r\n\r\n\r\n; Write a function which, given a key and map, returns true iff\r\n; the map contains an entry with that key and its value is nil.\r\n\r\n(def contains-and-nil?\r\n  (fn [k m]\r\n    (if (not (contains? m k))\r\n      false\r\n      (if (= nil (k m)) true false))))\r\n\r\n(defn contains-and-nil? [k m]\r\n  (if (not (contains? m k))\r\n      false\r\n      (if (= nil (k m))\r\n        true\r\n        false)))\r\n\r\n(true? (contains-and-nil? :a {:a nil :b 2}))\r\n(false? (contains-and-nil? :b {:a nil :b 2}))\r\n(false? (contains-and-nil? :c {:a nil :b 2}))\r\n\r\n; # 156  - given keys, create a new map map with a default value\r\n(defn mapk [default ks]\r\n  (zipmap ks (repeat (count ks) default)))\r\n\r\n(fn [default ks]\r\n  (zipmap ks (repeat (count ks) default)))\r\n\r\n; # 166\r\n; For any orderable data type it's possible to derive all of the basic comparison\r\n; operations (<, ≤, =, ≠, ≥, and >) from a single operation (any operator but = or ≠ will work).\r\n; Write a function that takes three arguments, a less than operator for the data and\r\n; two items to compare. The function should return a keyword describing the relationship\r\n; between the two items. The keywords for the relationship between x and y are as follows:\r\n; x = y → :eq\r\n; x > y → :gt\r\n; x < y → :lt\r\n\r\n(defn f1 [op x y]\r\n  (cond\r\n    (op x y) :lt\r\n    (= x y)  :eq\r\n    (not (op x y)) :gt))\r\n\r\n(fn [op x y]\r\n  (cond\r\n    (op x y) :lt\r\n    (op y x) :gt\r\n    (and (not (op x y))\r\n         (not (op y x))) :eq))\r\n\r\n;; #145.\r\n\r\n(for [x (range 40)\r\n      :when (= 1 (rem x 4))]\r\n  x)\r\n\r\n;; #99 Write a function which multiplies two numbers and returns the result as a sequence of its digits.\r\n;(= (__ 1 1) [1])\r\n;(= (__ 99 9) [8 9 1])\r\n;(= (__ 999 99) [9 8 9 0 1])\r\n\r\n(fn [x y]\r\n  (map #(- (int %) 48) (seq (str (* x y)))))\r\n\r\n; #122\r\n; Convert a binary number, provided in the form of a string, to its numerical value.\r\n; (= 0     (__ \"0\"))\r\n; (= 7     (__ \"111\"))\r\n; (= 8     (__ \"1000\"))\r\n; (= 9     (__ \"1001\"))\r\n; (= 255   (__ \"11111111\"))\r\n; (= 1365  (__ \"10101010101\"))\r\n; (= 65535 (__ \"1111111111111111\"))\r\n\r\n(fn [s]\r\n  (reduce\r\n    (fn [acc d] (+ (* 2 acc) d))\r\n    0\r\n    (map #(- (int %) 48) (seq s))))\r\n\r\n; #107 Given a positive integer n, return a function (f x) which computes x**n\r\n; (= 256 ((__ 2) 16),  ((__ 8) 2))\r\n; (= [1 8 27 64] (map (__ 3) [1 2 3 4]))\r\n; (= [1 2 4 8 16] (map #((__ %) 2) [0 1 2 3 4]))\r\n\r\n(fn [n]\r\n  (fn [x]\r\n    (loop [acc 1 i n]\r\n      (if (= i 0)\r\n        acc\r\n        (recur (* x acc) (dec i))))))\r\n\r\n\r\n; #135\r\n; infix calculator\r\n\r\n(fn [x op y & xs]\r\n  (loop [acc (op x y) r xs]\r\n    (if (empty? r)\r\n      acc\r\n      (let [[op2 y2 & more] r]\r\n        (recur (op2 acc y2) more)))))\r\n\r\n\r\n(infix 2 + 3)\r\n(infix 2 + 3 - 4)\r\n(infix 2 + 3 - 4 * 2)\r\n(infix 2 + 3 - 4 * 2 / 0.5 * 20)\r\n\r\n; #143 Create a function that computes the dot product of two sequences.\r\n; You may assume that the vectors will have the same length.\r\n\r\n(fn [c1 c2] (reduce + (map * c1 c2)))\r\n\r\n\r\n; #128 Recognize cards\r\n\r\n  (fn [card]\r\n  (let [suites {:S :spade :H :heart :D :diamond :C :club}\r\n        ranks  {:2 0  :3 1  :4 2  :5 3\r\n                :6 4  :7 5  :8 6  :9 7\r\n                :T 8  :J 9  :Q 10 :K 11\r\n                :A 12}\r\n         [i j] (map #(keyword  (str %)) (seq card))]\r\n    {:suit (suites i) :rank (ranks j)}))\r\n\r\n; #118 reimplement function map\r\n\r\n(fn ! [f coll]\r\n  (lazy-seq\r\n    (if coll\r\n      (cons (f (first coll)) (! f (next coll))))))\r\n\r\n\r\n; #105 Given an input sequence of keywords and numbers, create a map such that each key in\r\n; the map is a keyword, and the value is a sequence of all the numbers (if any)\r\n; between it and the next keyword in the sequence.\r\n; (= {} (__ []))\r\n; (= {:a [1]} (__ [:a 1]))\r\n\r\n(fn [m]\r\n  (second\r\n    (reduce\r\n      (fn [[slot acc] x]\r\n        (if (keyword? x)\r\n          [x    (assoc acc x [])]\r\n          [slot (assoc acc slot (conj (acc slot) x))]))\r\n      [nil {}]\r\n      m)))\r\n\r\n; # 102 When working with java, you often need to create an object with fieldsLikeThis,\r\n; but you'd rather work with a hashmap that has :keys-like-this until it's time to convert.\r\n; Write a function which takes lower-case hyphen-separated strings and converts them\r\n; to camel-case strings.\r\n;\r\n;(= (__ \"something\") \"something\")\r\n;(= (__ \"multi-word-key\") \"multiWordKey\")\r\n;(= (__ \"leaveMeAlone\") \"leaveMeAlone\")\r\n\r\n(fn [w]\r\n   (apply str (second\r\n          (reduce\r\n            (fn [[flag acc] x]\r\n              (if (= \\- x)\r\n                [true acc]\r\n                [false (if flag\r\n                  (conj acc (first (.. x toString toUpperCase)))\r\n                  (conj acc x))]))\r\n            [false []]\r\n          (seq w)))))\r\n\r\n\r\n; #137 Digits and bases\r\n;\r\n; Write a function which returns a sequence of digits of a non-negative number (first argument) in numerical\r\n; system with an arbitrary base (second argument). Digits should be represented with their integer values,\r\n; e.g. 15 would be [1 5] in base 10, [1 1 1 1] in base 2 and [15] in base 16.\r\n;\r\n; (= [1 2 3 4 5 0 1] (__ 1234501 10))\r\n; (= [0] (__ 0 11))\r\n; (= [1 0 0 1] (__ 9 2))\r\n\r\n(fn [num base]\r\n  (loop [acc [] n num]\r\n    (if (< n base)\r\n      (reverse (conj acc n))\r\n      (let [r (rem n base)]\r\n        (recur (conj acc r) (/ (- n r) base))))))\r\n\r\n; #132 Insert between two items\r\n\r\n(fn [op val coll]\r\n  (second\r\n    (reduce\r\n      (fn [[prev acc] x]\r\n        [x (if (op prev x)\r\n          (conj acc val x)\r\n          (conj acc x))])\r\n      [(first coll) []]\r\n      coll)))\r\n\r\n; #144\r\n; Write an oscillating iterate: a function that takes an initial value and a variable\r\n; number of functions. It should return a lazy sequence of the functions applied\r\n; to the value in order, restarting from the first function after it hits the end.\r\n(defn f1 [& mm]\r\n  (let [n (count mm)]\r\n    (lazy-seq\r\n      (loop [acc [] fs mm]\r\n        (recur (cons acc (first fs))))\r\n  (println mm))))\r\n\r\n; #97 Pascal's triangle\r\n; [1]\r\n; [1 1]\r\n; [1 2 1]\r\n; [1 3 3 1]\r\n\r\n; ! is a way to self-reference an anonymous function\r\n(fn ! [level]\r\n  (if (= 1 level)\r\n    [1]\r\n    (conj (second\r\n             (reduce\r\n                (fn [[prev acc] x]\r\n                  [x (conj acc (+ prev x))])\r\n                [0 []]\r\n                (! (dec level)))) 1)))\r\n\r\n; #95 Write a predicate which checks whether or not a given sequence represents a binary tree.\r\n; Each node in the tree must have a value, a left child, and a right child.\r\n\r\n(defn btree? [t]\r\n  (and\r\n    (sequential? t)\r\n    (= 3 (count t))\r\n    (let [[val left right] t]\r\n      (and\r\n        (not (sequential? val))\r\n        (not (nil? val))\r\n        (or (nil? left) (btree? left))\r\n        (or (nil? right) (btree? right))))))\r\n\r\n(fn ! [t]\r\n  (and\r\n    (sequential? t)\r\n    (= 3 (count t))\r\n    (let [[val left right] t]\r\n      (and\r\n        (not (sequential? val))\r\n        (not (nil? val))\r\n        (or (nil? left) (! left))\r\n        (or (nil? right) (! right))))))\r\n\r\n\r\n; # 120 Sum of square of digits\r\n; \r\n; Write a function which takes a collection of integers.\r\n; Return the count of how many elements are smaller\r\n; than the sum of their squared component digits. \r\n; For example: 10 is larger than 1 squared plus 0 squared;\r\n; whereas 15 is smaller than 1 squared plus 5 squared.\r\n\r\n(fn [coll]\r\n  (letfn [(int-to-seq [n] (map #(- (int %) 48) (seq (str n))))\r\n          (f2 [x] (if (< x\r\n                         (reduce (fn [acc n] (+ acc (* n n)))\r\n                                 0\r\n                                 (int-to-seq x)))\r\n                    1 0))]\r\n    (reduce (fn [acc x] (+ acc (f2 x))) 0 coll)))\r\n           \r\n\r\n; # 115 A balanced number is one whose component digits \r\n; have the same sum on the left and right halves of the number.\r\n; Write a function which accepts an integer n, and returns\r\n; true if n is balanced.\r\n\r\n(fn [n]\r\n  (cond (< n 0) false\r\n        (< n 9) true\r\n        :else (letfn [(int-to-seq [n] (map #(- (int %) 48) (seq (str n))))]\r\n                (let [s (vec (int-to-seq n))\r\n                      len (count s)\r\n                      m (int (/ len 2))\r\n                      l (subvec s 0 m)\r\n                      r (subvec s (+ m (if (even? len) 0 1)))]\r\n                  (= (reduce + l)\r\n                     (reduce + r))))))\r\n\r\n\r\n; #92 Read Roman numbers\r\n\r\n(fn [rom]\r\n  (let [roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\r\n        s (map roman (reverse (seq rom)))]\r\n    (second \r\n      (reduce (fn [[prev sum] n]\r\n                [n (+ sum (if (>= n prev) n (- n)))])\r\n              [0 0]\r\n              s))))\r\n\r\n\r\n; #121 Given a mathematical formula in prefix notation, return a\r\n; function that calculates the value of the formula. \r\n; The formula can contain nested calculations using the four \r\n; basic mathematical operators, numeric constants, and symbols\r\n; representing variables. The returned function has to accept \r\n; a single parameter containing the map of variable names to their values. \r\n\r\n(fn [expression]\r\n  (fn [m]\r\n    (letfn [(atomm? [x]\r\n                    (or (nil? x)\r\n                        (not (seq? x))))\r\n            (eva [exp]\r\n               (if (atomm? exp)\r\n                 (if (contains? m exp) (m exp) exp)\r\n                 (let [[op & args] exp]\r\n                   (cond\r\n                     (= '+ op) (apply + (map eva args))\r\n                     (= '- op) (apply - (map eva args))\r\n                     (= '* op) (apply * (map eva args))\r\n                     (= '/ op) (apply / (map eva args))                     \r\n                     :else 100))))]\r\n      (eva expression))))\r\n\r\n; #104 Write Roman numerals\r\n(fn [n]\r\n  (let [romans1 {1000 \"M\"  900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\r\n                 10 \"X\"  9 \"IX\" 8 \"VIII\" 7 \"VII\"\r\n                 6 \"VI\" 5 \"V\" 4 \"IV\" 3 \"III\" 2 \"II\" 1 \"I\"}]\r\n    (letfn [(find-range [n]\r\n                        (first (filter #(>= n %) (sort > (keys romans1)))))\r\n            (rom [n acc]\r\n                 (if (= 0 n)\r\n                   acc\r\n                   (let [r (find-range n)]\r\n                     (rom (- n r) (conj acc (romans1 r))))))]\r\n      (apply str (rom n [])))))\r\n\r\n\r\n; # 157 Transform a sequence into a sequence of pairs containing the original elements along with their index.\r\n\r\n(fn [coll] (map vector coll (range)))\r\n  \r\n; #100 write a function to calculate the least common multiplier\r\n\r\n(defn f [& args]\r\n  (letfn [(multipliers [n] (apply sorted-set (map #(* n %) (range 1 20))))]\r\n    (apply clojure.set/intersection (map multipliers args))))\r\n"]],"start1":0,"start2":0,"length1":0,"length2":17350}]],"length":17350,"saved":false}
